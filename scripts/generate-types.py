#!/usr/bin/env python3
"""
Generate TypeScript/JavaScript types from Pydantic models

این اسکریپت Pydantic models را می‌خواند و TypeScript/JavaScript types تولید می‌کند.
برای هماهنگی بین Backend و Frontend استفاده می‌شود.

Usage:
    python scripts/generate-types.py
"""

import json
import sys
from pathlib import Path
from typing import Dict, Any

# Add api directory to path
project_root = Path(__file__).parent.parent
api_dir = project_root / "api"
sys.path.insert(0, str(api_dir))

try:
    from psychology_engine import PsychologyAnalysisResult
    from cognitive_friction_engine import CognitiveFrictionResult, CognitiveFrictionInput
    from models.rewrite_models import RewriteInput, RewriteOutput
except ImportError as e:
    print(f"⚠️ Warning: Could not import models: {e}")
    print("This script requires the API models to be available.")
    sys.exit(1)


def pydantic_to_jsdoc_type(field_type: Any) -> str:
    """Convert Pydantic field type to JSDoc type"""
    type_str = str(field_type)
    
    if "List" in type_str or "list" in type_str.lower():
        # Extract inner type
        if "str" in type_str.lower():
            return "string[]"
        elif "int" in type_str.lower() or "float" in type_str.lower():
            return "number[]"
        else:
            return "Array<any>"
    
    if "float" in type_str.lower() or "int" in type_str.lower():
        return "number"
    
    if "str" in type_str.lower():
        return "string"
    
    if "bool" in type_str.lower():
        return "boolean"
    
    if "Optional" in type_str or "None" in type_str:
        return "any | null"
    
    return "any"


def generate_jsdoc(model_class, class_name: str) -> str:
    """Generate JSDoc type definition from Pydantic model"""
    lines = [f"/**", f" * @typedef {{Object}} {class_name}"]
    
    schema = model_class.model_json_schema()
    properties = schema.get("properties", {})
    required = schema.get("required", [])
    
    for prop_name, prop_info in properties.items():
        prop_type = prop_info.get("type", "any")
        description = prop_info.get("description", "")
        
        # Handle type conversion
        if prop_type == "array":
            items = prop_info.get("items", {})
            item_type = items.get("type", "any")
            if item_type == "string":
                js_type = "string[]"
            elif item_type == "number":
                js_type = "number[]"
            else:
                js_type = "Array<any>"
        elif prop_type == "number":
            # Check for constraints
            if "minimum" in prop_info or "maximum" in prop_info:
                js_type = "number"
            else:
                js_type = "number"
        elif prop_type == "string":
            js_type = "string"
        elif prop_type == "boolean":
            js_type = "boolean"
        else:
            js_type = "any"
        
        # Check if optional
        is_optional = prop_name not in required
        optional_marker = "?" if is_optional else ""
        
        # Build JSDoc line
        desc_part = f" - {description}" if description else ""
        lines.append(f" * @property {{{js_type}}} {optional_marker}{prop_name}{desc_part}")
    
    lines.append(" */")
    return "\n".join(lines)


def main():
    """Main function to generate types"""
    output_file = project_root / "web" / "types-generated.js"
    
    print("Generating TypeScript/JavaScript types from Pydantic models...")
    
    types_content = [
        "/**",
        " * Auto-generated types from Pydantic models",
        " * DO NOT EDIT THIS FILE MANUALLY",
        " * Run: python scripts/generate-types.py",
        " *",
        " * Last Generated: " + str(Path(__file__).stat().st_mtime),
        " */",
        "",
    ]
    
    # Generate types for each model
    models = [
        (PsychologyAnalysisResult, "PsychologyAnalysisResult"),
        (CognitiveFrictionResult, "CognitiveFrictionResult"),
        (CognitiveFrictionInput, "CognitiveFrictionInput"),
        (RewriteInput, "RewriteInput"),
        (RewriteOutput, "RewriteOutput"),
    ]
    
    for model_class, class_name in models:
        try:
            jsdoc = generate_jsdoc(model_class, class_name)
            types_content.append(jsdoc)
            types_content.append("")
            print(f"[OK] Generated type: {class_name}")
        except Exception as e:
            print(f"[WARNING] Error generating {class_name}: {e}")
    
    # Write to file
    output_file.write_text("\n".join(types_content), encoding="utf-8")
    print(f"[OK] Types written to: {output_file}")
    print(f"[INFO] Total types generated: {len(models)}")


if __name__ == "__main__":
    main()

