"""
English-only output enforcement utility.

Prevents any non-English text (especially Persian/Farsi) from reaching the client,
even if accidentally generated by the pipeline.

Instead of blanking content, rewrites it to safe English or generates fallback insights.
"""
import re
import logging
from typing import Any, Tuple, List, Dict

logger = logging.getLogger(__name__)

NON_EN_RE = re.compile(r"[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF]")

# Fallback texts for specific field types
FALLBACK_TEXTS = {
    "problem": "Low clarity: the page doesn't clearly state the primary offer and next step.",
    "why_it_hurts": "When users can't quickly understand what to do next, they hesitate and conversions drop.",
    "fix_steps": [
        "Add one clear primary CTA in the hero section.",
        "Clarify the offer in one sentence (who it's for + outcome).",
        "Place one trust signal near the CTA (metric, logo, or testimonial)."
    ],
    "evidence_value": "Page element detected but content requires review.",
    "quick_win_action": "Make the primary CTA more prominent and specific.",
    "quick_win_reason": "Clear next steps reduce hesitation and increase action."
}


def safe_en(text: str, fallback: str) -> str:
    """
    Replace placeholder string with safe English fallback.
    
    Args:
        text: Input text (may be None, empty, or contain placeholder)
        fallback: Fallback text to use if placeholder is detected
        
    Returns:
        Safe English text (original if valid, fallback if placeholder detected)
    """
    if not text or "[ENGLISH ONLY OUTPUT ENFORCED]" in text:
        return fallback
    return text


def _generate_page_map_driven_issues(page_map: Any, summary: Any) -> List[Dict[str, Any]]:
    """
    Generate actionable issues based on page_map data.
    
    Args:
        page_map: PageMap object or dict
        summary: Summary dict with counts
        
    Returns:
        List of issue dicts
    """
    issues = []
    
    # Convert page_map to dict if needed
    if hasattr(page_map, 'dict'):
        page_map_dict = page_map.dict()
    elif hasattr(page_map, '__dict__'):
        page_map_dict = page_map.__dict__
    else:
        page_map_dict = page_map if isinstance(page_map, dict) else {}
    
    # Check for missing primary CTA
    primary_cta = page_map_dict.get("primary_cta")
    primary_cta_text = None
    if isinstance(primary_cta, dict):
        primary_cta_text = primary_cta.get("text")
    elif hasattr(primary_cta, 'text'):
        primary_cta_text = primary_cta.text
    
    if not primary_cta_text or not primary_cta_text.strip():
        issues.append({
            "id": "missing_primary_cta",
            "severity": "high",
            "problem": "Missing primary call-to-action in the hero section.",
            "why_it_hurts": "Without a clear next step, users hesitate even if they like the offer.",
            "where": {
                "section": "hero",
                "selector": "a,button",
                "bbox": [0, 0, 0, 0],
                "screenshot_ref": "above_the_fold"
            },
            "evidence": [{
                "type": "ui",
                "value": "No primary CTA detected in hero section"
            }],
            "fix_steps": [
                "Add one primary CTA in the hero (e.g., 'Book a free call').",
                "Keep it visually dominant (button + contrast).",
                "Repeat CTA once after the first value paragraph."
            ]
        })
    
    # Check for unclear offer
    summary_dict = summary if isinstance(summary, dict) else {}
    headlines_count = summary_dict.get("headlines_count", 0)
    offer = page_map_dict.get("offer")
    
    if headlines_count >= 2 and (not offer or (isinstance(offer, dict) and not any(offer.values()))):
        issues.append({
            "id": "unclear_offer",
            "severity": "medium",
            "problem": "The offer is not clearly packaged into a single, scannable promise.",
            "why_it_hurts": "Users need a simple 'who + outcome' message within seconds.",
            "where": {
                "section": "hero",
                "selector": "h1,h2",
                "bbox": [0, 0, 0, 0],
                "screenshot_ref": "above_the_fold"
            },
            "evidence": [{
                "type": "text",
                "value": f"Multiple headlines ({headlines_count}) but no clear offer structure"
            }],
            "fix_steps": [
                "Rewrite subheadline as: 'I help [audience] achieve [outcome] using [method]'.",
                "Add 3 bullets: outcomes, timeline, proof.",
                "Move non-essential nav links below the fold on mobile."
            ]
        })
    
    return issues


def _generate_page_map_driven_quick_wins(page_map: Any) -> List[Dict[str, Any]]:
    """
    Generate concrete quick wins based on page_map data.
    
    Args:
        page_map: PageMap object or dict
        
    Returns:
        List of quick_win dicts
    """
    quick_wins = []
    
    # Convert page_map to dict if needed
    if hasattr(page_map, 'dict'):
        page_map_dict = page_map.dict()
    elif hasattr(page_map, '__dict__'):
        page_map_dict = page_map.__dict__
    else:
        page_map_dict = page_map if isinstance(page_map, dict) else {}
    
    # Check headline clarity
    headline = page_map_dict.get("headline", "")
    if not headline or len(headline.strip()) < 20:
        quick_wins.append({
            "action": "Rewrite headline to state the primary outcome in 8-12 words.",
            "reason": "Short, outcome-focused headlines reduce cognitive load and increase clarity."
        })
    
    # Check for trust signals
    trust_signals = page_map_dict.get("trust_signals", [])
    if not trust_signals or len(trust_signals) == 0:
        quick_wins.append({
            "action": "Add one trust signal above the fold (testimonial quote, client logo, or guarantee badge).",
            "reason": "Trust signals near the offer reduce perceived risk and increase conversion."
        })
    elif len(trust_signals) < 2:
        quick_wins.append({
            "action": "Add a second trust signal (metric, case study link, or social proof).",
            "reason": "Multiple trust signals create a stronger credibility foundation."
        })
    
    # Check CTA visibility
    primary_cta = page_map_dict.get("primary_cta")
    if primary_cta:
        cta_text = primary_cta.get("text") if isinstance(primary_cta, dict) else (primary_cta.text if hasattr(primary_cta, 'text') else None)
        if cta_text and len(cta_text.strip()) > 0:
            if len(cta_text) > 20:
                quick_wins.append({
                    "action": f"Shorten CTA text from '{cta_text[:30]}...' to 2-4 words (e.g., 'Get Started').",
                    "reason": "Shorter CTAs are scannable and reduce decision friction."
                })
        else:
            quick_wins.append({
                "action": "Add a specific action-oriented CTA button in the hero section.",
                "reason": "Clear next steps eliminate hesitation and guide users to conversion."
            })
    
    # Check subheadline
    subheadline = page_map_dict.get("subheadline", "")
    if not subheadline or len(subheadline.strip()) < 15:
        quick_wins.append({
            "action": "Add a one-sentence subheadline that explains the primary benefit.",
            "reason": "Subheadlines clarify the value proposition and support the headline."
        })
    
    # Ensure we have at least 3 quick wins
    while len(quick_wins) < 3:
        quick_wins.append({
            "action": "Review page structure and ensure one clear conversion path is visible above the fold.",
            "reason": "Single, clear conversion paths reduce choice paralysis and increase action."
        })
    
    return quick_wins[:3]  # Return max 3


def _generate_fallback_insight(original_text: str, context: str = "content", page_map: Any = None) -> str:
    """
    Generate a fallback English insight when non-English content is detected.
    Uses page_map data when available for more specific insights.
    
    Args:
        original_text: Original text that contained non-English characters
        context: Context hint (e.g., "issue", "quick_win", "description")
        page_map: Optional PageMap for context-specific fallbacks
        
    Returns:
        Safe English fallback text (never generic filler)
    """
    # Try to use page_map for context-specific fallbacks
    if page_map:
        page_map_dict = page_map.dict() if hasattr(page_map, 'dict') else (page_map if isinstance(page_map, dict) else {})
        headline = page_map_dict.get("headline", "")
        
        if headline and len(headline.strip()) > 0:
            if context == "issue":
                return f"Analysis of '{headline[:50]}...' identified a conversion barrier requiring attention."
            elif context == "quick_win":
                return f"Quick improvement opportunity identified for '{headline[:50]}...' page structure."
            elif context == "description":
                return f"Analysis completed for page with headline: '{headline[:50]}...'"
    
    # Context-specific fallbacks (never generic filler)
    fallbacks = {
        "issue": "Conversion barrier detected that requires attention.",
        "issue_problem": "This issue is reducing confidence near the primary CTA.",
        "issue_why": "When users can't quickly understand what to do next, they hesitate and conversions drop.",
        "quick_win": "Quick improvement opportunity identified in page structure.",
        "quick_win_action": "Make the primary CTA more prominent and specific.",
        "quick_win_reason": "Clear next steps reduce hesitation and increase action.",
        "description": "Page analysis completed with actionable findings.",
        "title": "Page Analysis",
        "content": "Analysis completed with specific recommendations."
    }
    
    # Try to extract any English words from original text
    english_words = re.findall(r'[a-zA-Z]+', original_text)
    if english_words and len(english_words) > 0 and page_map:
        # Use page_map context for more specific fallback
        page_map_dict = page_map.dict() if hasattr(page_map, 'dict') else (page_map if isinstance(page_map, dict) else {})
        headline = page_map_dict.get("headline", "")
        if headline:
            return f"Analysis of '{headline[:40]}...' identified conversion barriers requiring attention."
    
    # Use context-specific fallback (never "Content analysis completed successfully" or generic "Analysis identified X")
    return fallbacks.get(context, fallbacks["content"])


def sanitize_string(s: str, context: str = "content", page_map: Any = None) -> Tuple[str, bool]:
    """
    Sanitize a string by rewriting non-English content to safe English.
    
    Args:
        s: Input string
        context: Context hint for generating appropriate fallback
        page_map: Optional PageMap for context-specific fallbacks
        
    Returns:
        Tuple of (sanitized_string, was_rewritten)
        - sanitized_string: Safe English text (original if no non-English chars, rewritten otherwise)
        - was_rewritten: True if content was rewritten, False if original was kept
    """
    if not s:
        return s, False
    
    if NON_EN_RE.search(s):
        # Non-English detected - rewrite to safe English using page_map context
        fallback = _generate_fallback_insight(s, context, page_map)
        logger.warning(f"Non-English content detected and rewritten. Context: {context}, Original length: {len(s)}")
        return fallback, True
    
    return s, False


def enforce_english_only(obj: Any, mode: str = "unknown", debug: dict = None, page_map: Any = None, summary: Any = None) -> Tuple[Any, dict]:
    """
    Recursively enforce English-only output on any object structure.
    
    Instead of blanking content, rewrites it to safe English or generates fallback insights.
    Ensures minimum issues/quick_wins for URL mode.
    
    Works on:
    - Strings: Rewrites non-English chars to safe English
    - Lists: Recursively processes each element
    - Dicts: Recursively processes each value (keys are preserved)
    - Other types: Returned as-is
    
    Args:
        obj: Any object (str, list, dict, etc.)
        mode: Analysis mode ("url", "image", "text") for minimum requirements
        debug: Debug dict to update with low_confidence flag
        
    Returns:
        Tuple of (sanitized_object, stats_dict)
        - sanitized_object: Object with all non-English text rewritten
        - stats_dict: Statistics about rewrites (rewrites_count, low_confidence)
    """
    if debug is None:
        debug = {}
    
    stats = {
        "rewrites_count": 0,
        "low_confidence": False
    }
    
    def _process_value(value: Any, key_path: str = "") -> Any:
        """Recursively process a value."""
        if isinstance(value, str):
            # Determine context from key_path for better fallback generation
            context = "content"
            if "quick_win" in key_path.lower() or "quick_wins" in key_path.lower():
                if "action" in key_path.lower():
                    context = "quick_win_action"
                elif "reason" in key_path.lower():
                    context = "quick_win_reason"
                else:
                    context = "quick_win"
            elif "issue" in key_path.lower() or "issues" in key_path.lower():
                if "problem" in key_path.lower():
                    context = "issue_problem"
                elif "why_it_hurts" in key_path.lower():
                    context = "issue_why"
                else:
                    context = "issue"
            elif "human_report" in key_path.lower() or "report" in key_path.lower():
                context = "description"
            
            sanitized, was_rewritten = sanitize_string(value, context=context, page_map=page_map)
            if was_rewritten:
                stats["rewrites_count"] += 1
                stats["low_confidence"] = True
            return sanitized
        elif isinstance(value, list):
            return [_process_value(x, key_path) for x in value]
        elif isinstance(value, dict):
            return {k: _process_value(v, f"{key_path}.{k}" if key_path else k) for k, v in value.items()}
        else:
            return value
    
    result = _process_value(obj)
    
    # Ensure minimum issues/quick_wins for URL mode using page_map-driven generation
    if mode == "url" and isinstance(result, dict):
        # Get current issues
        issues = result.get("issues", [])
        if not isinstance(issues, list):
            issues = []
        
        # Get summary for page_map-driven generation
        result_summary = summary if summary else result.get("summary", {})
        
        # Generate page_map-driven issues if we have page_map
        if page_map and len(issues) < 2:
            stats["low_confidence"] = True
            page_map_issues = _generate_page_map_driven_issues(page_map, result_summary)
            # Add page_map-driven issues (avoid duplicates by checking IDs)
            existing_ids = {issue.get("id") for issue in issues if isinstance(issue, dict) and "id" in issue}
            for pm_issue in page_map_issues:
                if isinstance(pm_issue, dict) and pm_issue.get("id") not in existing_ids:
                    issues.append(pm_issue)
                    existing_ids.add(pm_issue.get("id"))
        
        # Ensure minimum 2 issues (use page_map-driven if available, otherwise generic)
        if len(issues) < 2:
            stats["low_confidence"] = True
            # Only use generic fallback if page_map not available
            if not page_map:
                fallback_issues = [
                    {
                        "id": "conversion_barrier",
                        "type": "conversion_barrier",
                        "severity": "medium",
                        "problem": "Multiple conversion barriers detected that may impact user decision-making.",
                        "why_it_hurts": "When multiple barriers exist, users hesitate and conversion rates drop significantly.",
                        "where": {
                            "section": "page",
                            "selector": "body",
                            "bbox": [0, 0, 0, 0],
                            "screenshot_ref": "full_page"
                        },
                        "evidence": [{
                            "type": "analysis",
                            "value": "Multiple conversion barriers identified in analysis"
                        }],
                        "fix_steps": [
                            "Identify and prioritize the top 3 conversion barriers.",
                            "Address the highest-impact barrier first.",
                            "Test changes and measure conversion impact."
                        ]
                    },
                    {
                        "id": "user_experience",
                        "type": "user_experience",
                        "severity": "medium",
                        "problem": "User experience elements require optimization to improve conversion rates.",
                        "why_it_hurts": "Poor UX creates friction that prevents users from completing desired actions.",
                        "where": {
                            "section": "page",
                            "selector": "body",
                            "bbox": [0, 0, 0, 0],
                            "screenshot_ref": "full_page"
                        },
                        "evidence": [{
                            "type": "analysis",
                            "value": "UX optimization opportunities identified"
                        }],
                        "fix_steps": [
                            "Simplify navigation and reduce cognitive load.",
                            "Improve visual hierarchy and CTA placement.",
                            "Optimize mobile experience for better usability."
                        ]
                    }
                ]
                needed = 2 - len(issues)
                for i in range(needed):
                    if i < len(fallback_issues):
                        issues.append(fallback_issues[i])
            else:
                # Generate more page_map-driven issues or use generic fallback
                page_map_issues = _generate_page_map_driven_issues(page_map, result_summary)
                existing_ids = {issue.get("id") for issue in issues if isinstance(issue, dict) and "id" in issue}
                for pm_issue in page_map_issues:
                    if isinstance(pm_issue, dict) and pm_issue.get("id") not in existing_ids and len(issues) < 2:
                        issues.append(pm_issue)
                        existing_ids.add(pm_issue.get("id"))
                
                # If still less than 2, add generic fallback
                if len(issues) < 2:
                    fallback_issues = [
                        {
                            "id": "conversion_barrier",
                            "type": "conversion_barrier",
                            "severity": "medium",
                            "problem": "Multiple conversion barriers detected that may impact user decision-making.",
                            "why_it_hurts": "When multiple barriers exist, users hesitate and conversion rates drop significantly.",
                            "where": {
                                "section": "page",
                                "selector": "body",
                                "bbox": [0, 0, 0, 0],
                                "screenshot_ref": "full_page"
                            },
                            "evidence": [{
                                "type": "analysis",
                                "value": "Multiple conversion barriers identified in analysis"
                            }],
                            "fix_steps": [
                                "Identify and prioritize the top 3 conversion barriers.",
                                "Address the highest-impact barrier first.",
                                "Test changes and measure conversion impact."
                            ]
                        }
                    ]
                    needed = 2 - len(issues)
                    for i in range(needed):
                        if i < len(fallback_issues):
                            fb_issue = fallback_issues[i].copy()
                            if fb_issue.get("id") not in existing_ids:
                                issues.append(fb_issue)
                                existing_ids.add(fb_issue.get("id"))
        
        result["issues"] = issues
        result["issues_count"] = len(issues)
        
        # Get current quick_wins
        quick_wins = result.get("quick_wins", [])
        if not isinstance(quick_wins, list):
            quick_wins = []
        
        # Generate page_map-driven quick_wins if we have page_map
        if page_map and len(quick_wins) < 3:
            stats["low_confidence"] = True
            page_map_quick_wins = _generate_page_map_driven_quick_wins(page_map)
            # Add page_map-driven quick_wins
            quick_wins.extend(page_map_quick_wins[:3])
            quick_wins = quick_wins[:3]  # Keep max 3
        
        # Ensure minimum 3 quick_wins
        if len(quick_wins) < 3:
            stats["low_confidence"] = True
            # Only use generic fallback if page_map not available
            if not page_map:
                fallback_quick_wins = [
                    {
                        "action": "Optimize headline clarity to state the primary outcome in 8-12 words.",
                        "reason": "Clear, outcome-focused headlines reduce cognitive load and improve value communication."
                    },
                    {
                        "action": "Enhance CTA visibility with higher contrast and larger size in the hero section.",
                        "reason": "Prominent CTAs reduce decision friction and increase conversion rates."
                    },
                    {
                        "action": "Add trust signals (testimonials, guarantees, or client logos) near the primary CTA.",
                        "reason": "Trust signals reduce perceived risk and hesitation, increasing conversion."
                    }
                ]
                needed = 3 - len(quick_wins)
                for i in range(needed):
                    if i < len(fallback_quick_wins):
                        quick_wins.append(fallback_quick_wins[i])
            else:
                # Generate more page_map-driven quick_wins
                page_map_quick_wins = _generate_page_map_driven_quick_wins(page_map)
                for pm_qw in page_map_quick_wins:
                    if len(quick_wins) < 3:
                        quick_wins.append(pm_qw)
        
        result["quick_wins"] = quick_wins[:3]  # Keep max 3
        result["quick_wins_count"] = len(result["quick_wins"])
        
        # Update summary counts
        result_summary = result.get("summary", {})
        if isinstance(result_summary, dict):
            result_summary["issues_count"] = len(issues)
            result_summary["quick_wins_count"] = len(result["quick_wins"])
            result["summary"] = result_summary
        
        # Set low_confidence flag in debug
        if stats["low_confidence"]:
            if "debug" not in result:
                result["debug"] = {}
            result["debug"]["low_confidence"] = True
            result["debug"]["rewrites_count"] = stats["rewrites_count"]
            if debug:
                debug["low_confidence"] = True
    
    return result, stats


